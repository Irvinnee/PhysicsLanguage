int func factorial(float x):
    int i = 1
    while(x>0):
        i = i*x
        x = x-1
        print(i)
        print(x)

    => x

print(factorial(5.5))

tak to się miało wykonywać czy od razu znaleźć że zwraca zły typ i wywalić przy deklaracji?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

$TIME >= 8  -jako licznik, delta jako delta + max time
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SPRAWDZIC::::

obsługę definiowania i wywoływania funkcji. Funkcja powinna pozwalać na zwracanie rezultatu (powinna istnieć też możliwość definiowania funkcji zwracającej void) i przyjmować zadeklarowaną liczbę oraz typy argumentów.











nihil mumus test 5(bumerus i):

numerus x esto i.

si x maior quam 0:

test5(i minue 1).

aaa

jak towarzymy nowy rekord aktywacji - tworzą się nowe zmienne

funkcja co ma dwa argumenty wywołujemy bez argumentó - ma mieć błąd także podczas wywołanie innej funkcji, nie tylko w przestrzeni globalnej

pisać gdzie pierwszy raz zadklarowana funkcja/zmienna

funkcja w funkcji, wywoływanie, ale też zmiany na x (zadeklarowana poza, i wypisuje potem zmiany po wowoływaniu funkcji)

odwoływanie do globalnej zmiennej w scopie

deklarujemy x w funkcji, która jest w innej funkcji gdzie jest x

lokalny scope - czy rekordy aktywacji odpowiednio się wyowułują

dostęp do zmiennych globalnych - w rekordzie katywacji tylko zmienne lokalne