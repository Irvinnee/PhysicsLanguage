int func factorial(int x):
    int i = 1
    while(x>0):
        i = i*x
        x = x-1
        print(i)
        print(x)

    => x

int a = 5
factorial(a)
print(a)

zmienne nie miały się nadpisywać?? miało wyjść 0?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
int func factorial(float x):
    int i = 1
    while(x>0):
        i = i*x
        x = x-1
        print(i)
        print(x)

    => x

print(factorial(5.5))

tak to się miało wykonywać czy od razu znaleźć że zwraca zły typ i wywalić przy deklaracji?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

$TIME >= 8  -jako licznik, delta jako delta + max time
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SPRAWDZIC::::

obsługę definiowania i wywoływania funkcji. Funkcja powinna pozwalać na zwracanie rezultatu (powinna istnieć też możliwość definiowania funkcji zwracającej void) i przyjmować zadeklarowaną liczbę oraz typy argumentów.





function test (a: real, b:real):real <

return a + b;

>

kazał zmienić na a:real, a: real i dać a+a

print(”<test(5.0, 10.0)>”);

boole nie castowane na floaty

operatory castowania?

automatyczne castowanie z int na real

jeśli dwie takie same nazwy argumentów to to sprawdzać, że źle (a:real, a:real)

pętla

repeat as_number(a) <

print(.);

nie robić return zawsze

sprawdzanie kolejności wywołań rekurencji przez print w ciągu fibonacciego (co wywołało dla czego

funkcja1 - wywołujemy funkcje 2 w funkcji1 ale funkcja 2 jest zadeklarowana po funkcji1
deklaracja wstępna? - słownik zapisujący nazwy wszystkich funkcji

sprawdzić wywoływanie funkcji1 w funkcji2, dekularujemy funkcje1 na poczatku funkcji2?

syntax error

zachwoanie pamięci zmiennych w rekurencji

każde wywłoanie funkcji ma swój rekord aktywacji i każde wywołanie zmiennych????

rekurencja dokładnie trzeba zrobić!!

działanie ze stosem

fun (num a, num, a) - podwójna deklaracja

repetere i ex 5 ad 1: od 5 do 1 - ma być błąd

rekurencja niebezpośrdnia i pośrednia (od razu w funkcji tej i w funkcji innej)

nihil mumus test 5(bumerus i):

numerus x esto i.

si x maior quam 0:

test5(i minue 1).

aaa

jak towarzymy nowy rekord aktywacji - tworzą się nowe zmienne

funkcja co ma dwa argumenty wywołujemy bez argumentó - ma mieć błąd także podczas wywołanie innej funkcji, nie tylko w przestrzeni globalnej

pisać gdzie pierwszy raz zadklarowana funkcja/zmienna

funkcja w funkcji, wywoływanie, ale też zmiany na x (zadeklarowana poza, i wypisuje potem zmiany po wowoływaniu funkcji)

odwoływanie do globalnej zmiennej w scopie

deklarujemy x w funkcji, która jest w innej funkcji gdzie jest x

lokalny scope - czy rekordy aktywacji odpowiednio się wyowułują

dostęp do zmiennych globalnych - w rekordzie katywacji tylko zmienne lokalne